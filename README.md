**CSCI 2100 Final Report**

**Bella Ott and Cole Patrick**

**Saint Louis University**


**<ins>Section I: Introduction</ins>**

This program collects speed data from the GPS and the smartwatch datasets via the provided text file, identifies statistically anomalous entries, and estimates the actual speed based on the average difference between entries. The majority of this program is compartmentalized into the class called “speed” which holds all sensor speed data, estimated speed, and functions. The object created by this class is accessed using the main program which has a while loop that can call necessary functions, including search and display functions, from which the user can choose.

**<ins>Section II: Design Details</ins>**

**main.cpp**

The main.cpp of our program initializes the speed object through the included .hpp and .cpp files. The user then responds to the query that can (1) search for speed, (2) search for time, (3) display all data, or (4) exit. The while loop (menu) will begin and the user’s first choice will be executed. If another input is required (1 or 2) then the choice variable is reused and the corresponding function in the object is called. The next menu option is requested and the loop repeats.

**speed.hpp**

The speed.hpp file shows the overall structure of the object. There are two arrays which hold the initial data from the two text files, and a third array containing the estimate generated by the program. The average acceleration is also stored for use. These are private to prevent unexpected behavior.
The first four functions are called upon object construction (openFiles, calcAcc, findErrors, and actualSpeed). These are public in case custom usage is necessary, for example changing the original text file and then calling openFiles() again would input the text file’s new data rather than the old data.
The second cluster of functions (searchByTime, searchbyGPSSpeed, searchByWatchSpeed, and display) are run by the user in the main function to fulfill their requests. They are all public by necessity.

**speed.cpp**

The speed.cpp file defines the behaviors found in speed.hpp, and so is included in this file. The cmath library is required for some statistics and number manipulation, and the fstream library provides functionality for reading input files.

The speed constructor starts the speeds for all data sets at time 0 to 0 and calls the first four functions mentioned above. The deconstructor does not delete anything special beyond the default C++ deconstruction, but outputs a message to signal its deletion.

The openFiles function uses two ifstream objects to retrieve the .txt files needed for the program, inputs the speed of each line into each location in the gpsSpeed and watchSpeed arrays respectively, and then closes the file. If either of the files fail to open (wrong file path or otherwise), then the program notifies the user of the error and quits the function. The program will continue to run, but all data and operations will be erroneous.
 
The calcAcc function sums the differences between each consecutive pair for each dataset, then divides the final sum to find the average acceleration. This average is reported to the user and stored in the avgAcc variable for later functions.

The findErrors function uses the given variance of 0.1 to determine which entries are statistical outliers based on the average and standard deviations. The loop moves chronologically through the entries for both datasets and will output a message for every entry that is above or below the expected boundaries, which are declared in the upperBound and lowerBound variables. We used 3 standard deviations as our range, but could increase our discrimination by using 2 standard deviations instead. In either case, the same outliers are calculated (for this data set, the outliers are significantly far).

The actualSpeed function calculates the estimated speed based on the fact that the acceleration is constant (linear regression line) and places the values into the actualSpeedArr array variable.

The searchByTime function takes a time input from the user as the parameter to find a speed at the given time. The array indexes match the respective timestamps. There is some simple logic to make sure we are not reading outside of the array (0 <= x <= 99). If the input is within the range, the function outputs the speeds in gpsSpeed, watchSpeed, and actualSpeedArr at the inputted index location.

The searchByGPSSpeed and searchByWatchSpeed functions are identical, besides which array they read from. This utilizes a linear search with time complexity O(n). As we iterate through the array, we round the current value and check if it matches our target given by the input parameter, and return early if the desired speed is found. We did experiment with an O(log n) algorithm through a binary search, but we did not want to have to do unnecessary sorting to account for the outliers.
Lastly, the display function iterates through all 100 data points in each array and outputs them for the user to view.

**<ins>Section III: Results</ins>**

Immediately after running the program, the output immediately displays the average acceleration and all anomalous data caught by the program. It also prompts the user to choose to search for a speed, to display the data, or to exit the program.

After inputting 1, the program requests a whole number to search for, and finds the value within the rounded range for each data set. As shown, an input like 75 will still retrieve the value 74.9904 at time 75 despite that not being the search term. It will also not find a speed of 75 for the watch, as there is no speed 74.5 < x < 75.5 that exists in the watch data because of erroneous data. The program will then prompt the user for the next command.

If the user wanted to see what data was at time 75 for the watch, the user would input 2, and then 75. Then, it would show the speed we found before as well as the speed that existed in that space instead, as well as the calculated estimate by the program. As before, it loops the menu.

If you were to input a time outside of the index domain, the program would specify that it was out of range.

If we input 3, the program would display the time and the speed from both sensors as well as the estimate. Menu loops once again.

After inputting any other number, the program deconstructs the object and exits.
